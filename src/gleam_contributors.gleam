// Import Gleam StdLib modules here.
// To add an Erlang library, add deps to rebar.config, AND require lib in
// gleam_contributors.app.src To use them create an external fn.
import gleam/result
import gleam/dynamic
import gleam/map
import gleam/string
import gleam/set.{Set}
import gleam/list
import gleam/int
import gleam/io
import gleam/option.{None, Option, Some}
import gleam_contributors/json
import gleam_contributors/graphql
import gleam_contributors/markdown
import gleam_contributors/sponsor.{Sponsor}
import gleam_contributors/contributor.{Contributor}

external type OkAtom

// Naming the application for Erlang to start processes required in app, such as
// inets. Will convert Camel to Snake case.
type Application {
  GleamContributors
}

//Erlang module Application fn ensure_all_started, see above
external fn start_application_and_deps(Application) -> OkAtom =
  "application" "ensure_all_started"

//Erlang library for datetime
external fn current_time() -> tuple(Int, Int, Int) =
  "calendar" "universal_time"

external fn iso_format(tuple(Int, Int, Int)) -> String =
  "iso8601" "format"

//TODO err is atom type not string, import gleam atom then if need error convert atom to string
external fn read_file(filename: String) -> Result(String, String) =
  "file" "read_file"

//TODO error is atom type not string, import gleam atom then if need error convert atom to string
//TODO Correct return type
external fn write_file(
  filename: String,
  content: String,
) -> Result(String, String) =
  "file" "write_file"

pub type Repo {
  Repo(org: String, name: String)
}

// Converts response json to datetime string.
pub fn parse_datetime(json_payload: String) -> Result(String, String) {
  let res = json.decode(json_payload)
  try data = dynamic.field(res, "data")
  try repo = dynamic.field(data, "repository")
  try release = dynamic.field(repo, "release")
  try tag = dynamic.field(release, "tag")
  try target = dynamic.field(tag, "target")
  try dynamic_date = dynamic.field(target, "committedDate")
  try date = dynamic.string(dynamic_date)

  Ok(date)
}

// Calls API with versions and gets datetimes for the version release dates
fn call_api_for_datetimes(
  token: String,
  from_version: String,
  to_version: Option(String),
) -> Result(tuple(String, String), String) {
  try to_datetime = case to_version {
    Some(to_version) -> {
      let query_to = graphql.construct_release_query(to_version)
      try response_json = graphql.call_api(token, query_to)
      parse_datetime(response_json)
    }
    None -> Ok(iso_format(current_time()))
  }

  let query_from = graphql.construct_release_query(from_version)
  try response_json = graphql.call_api(token, query_from)
  try from_datetime = parse_datetime(response_json)

  Ok(tuple(from_datetime, to_datetime))
}

pub fn list_sponsor_to_list_string(sponsors_list: List(Sponsor)) -> List(String) {
  sponsors_list
  |> list.map(fn(record: Sponsor) {
    let name = sponsor.display_name(record)
    let href = sponsor.display_link(record)
    markdown.link(name, to: href)
  })
  |> case_insensitive_sort
}

// Filters sponsor list to people who have donated `dollars` or above
pub fn filter_sponsors(lst: List(Sponsor), dollars: Int) -> List(Sponsor) {
  let cents = dollars * 100
  list.filter(lst, fn(sponsor: Sponsor) { sponsor.cents >= cents })
}

fn call_api_for_sponsors(
  token: String,
  cursor: Option(String),
  sponsor_list: List(Sponsor),
) -> Result(List(Sponsor), String) {
  let query = graphql.construct_sponsor_query(cursor, option.None)

  try response_json = graphql.call_api(token, query)
  let response_json = json.decode(response_json)
  try sponsorpage = sponsor.decode_page(response_json)

  //The sponsor_list acts as an accumluator on the recursive call of the fn,
  //and is therefore passed in as an arg.
  let sponsor_list = list.append(sponsor_list, sponsorpage.sponsor_list)

  case sponsorpage.nextpage_cursor {
    Ok(cursor) -> {
      let cursor_opt = option.Some(cursor)
      call_api_for_sponsors(token, cursor_opt, sponsor_list)
    }
    _ -> Ok(sponsor_list)
  }
}

fn github_actions(token: String, filename: String) -> Result(String, String) {
  io.println("Calling Sponsors API")
  try sponsors = call_api_for_sponsors(token, option.None, [])
  io.println("Reading target file")
  try file = read_file(filename)
  io.println("Editing file contents")
  let splitter = "<!-- Below this line this file is autogenerated -->"
  let parts = string.split(file, splitter)
  try part_one =
    list.head(parts)
    |> result.map_error(fn(_) { "Could not split file." })

  // Get sponsors over $10 for generated readme section
  let sponsors100 = filter_sponsors(sponsors, 10)
  let str_lst_sponsors = list_sponsor_to_list_string(sponsors100)
  let output_sponsors = markdown.unordered_list(str_lst_sponsors)

  // recombine partone with the autogenerated bit and sponsors into a string
  let gen_readme = string.concat([part_one, splitter, "\n", output_sponsors])

  // write to file
  io.println("Writing edited content to target file")
  // try out = write_file("README.md", gen_readme)
  // The write_file Erlang fn does NOT return a result so we need to hack it
  // until there are better bindings to the file IO library.
  case write_file(filename, gen_readme) {
    Error(e) -> Error(e)
    _ -> Ok("")
  }
}

//Parse args from STDIN
fn parse_args(
  args: List(String),
) -> Result(tuple(String, String, String), String) {
  case args {
    [token, from_version, to_version] -> {
      // From and to dates from version numbers
      try datetimes =
        call_api_for_datetimes(token, from_version, Some(to_version))
      let tuple(from, to) = datetimes
      Ok(tuple(token, from, to))
    }
    [token, from_version] -> {
      try datetimes = call_api_for_datetimes(token, from_version, None)
      let tuple(from, to) = datetimes
      Ok(tuple(token, from, to))
    }
    _ ->
      Error(
        "Usage: _buildfilename $TOKEN $FROM_VERSION $TO_VESRION
Version should be in format `v0.3.0`
$TO_VERSION is optional and if omitted, records will be retrieved up to the current datetime.",
      )
  }
}

//Uses the uniqueness property of sets to remove duplicates from list
pub fn remove_duplicates(sponsors_list: List(String)) -> Set(String) {
  list.fold(
    over: sponsors_list,
    from: set.new(),
    with: fn(elem, acc) { set.insert(acc, elem) },
  )
}

pub fn list_contributor_to_list_string(
  contributors: List(Contributor),
) -> List(String) {
  let initial_list =
    contributors
    |> list.map(fn(contributor: Contributor) {
      case contributor.github {
        Some(url) -> markdown.link(contributor.name, to: url)
        None -> contributor.name
      }
    })

  // TODO: can the filter and sort be handled later or is here best?
  let case_insensitive_string_compare = fn(a, b) {
    string.compare(string.lowercase(a), string.lowercase(b))
  }

  let sorted = list.sort(initial_list, case_insensitive_string_compare)

  remove_duplicates(sorted)
  |> set.to_list
}

pub fn filter_creator_from_contributors(
  lst: List(Contributor),
) -> List(Contributor) {
  let creator =
    Contributor(name: "Louis Pilfold", github: Some("https://github.com/lpil"))
  list.filter(lst, fn(elem) { elem != creator })
}

fn request_and_parse_contributors(
  token,
  from,
  to,
  cursor,
  org,
  repo_name,
  branch,
) {
  let query =
    graphql.construct_contributor_query(
      cursor,
      from,
      to,
      option.None,
      org,
      repo_name,
      branch,
    )

  try response_json = graphql.call_api(token, query)
  try contributorpage = contributor.decode_page(response_json)
  Ok(contributorpage)
}

fn call_api_for_contributors(
  token: String,
  from: String,
  to: String,
  cursor: Option(String),
  contributor_list: List(Contributor),
  org: String,
  repo_name: String,
) -> Result(List(Contributor), String) {
  ["Calling API for contributors to ", org, "/", repo_name]
  |> string.concat
  |> io.println

  let fetch_and_parse = fn(branch) {
    request_and_parse_contributors(
      token,
      from,
      to,
      cursor,
      org,
      repo_name,
      branch,
    )
  }

  try contributorpage = case fetch_and_parse("main") {
    Ok(data) -> Ok(data)
    Error(_) -> fetch_and_parse("master")
  }

  let contributor_list =
    list.append(contributor_list, contributorpage.contributor_list)

  case contributorpage.nextpage_cursor {
    Ok(cursor) -> {
      let cursor_opt = option.Some(cursor)
      call_api_for_contributors(
        token,
        from,
        to,
        cursor_opt,
        contributor_list,
        org,
        repo_name,
      )
    }
    _ -> Ok(contributor_list)
  }
}

fn case_insensitive_sort(items: List(String)) -> List(String) {
  let case_insensitive_string_compare = fn(a, b) {
    string.compare(string.lowercase(a), string.lowercase(b))
  }

  list.sort(items, case_insensitive_string_compare)
}

// TODO Add nextpage cursor for when number of repos exceed 100 results
fn parse_repos(repos_json: String, org_n: String) -> Result(List(Repo), String) {
  let res = json.decode(repos_json)
  try data = dynamic.field(res, "data")
  try org = dynamic.field(data, "organization")
  try repos = dynamic.field(org, "repositories")
  try nodes = dynamic.field(repos, "nodes")
  let name_field = fn(repo) {
    try dynamic_name = dynamic.field(repo, "name")
    dynamic.string(dynamic_name)
  }
  try repo_string_list = dynamic.typed_list(nodes, of: name_field)

  let list_repo =
    list.map(repo_string_list, fn(string) { Repo(org: org_n, name: string) })

  Ok(list_repo)
}

// Query for getting all of the repos
fn construct_repo_query(org: String) -> String {
  string.concat([
    "
  query {
  organization(login: \"",
    org,
    "\")
  {
    name
    url
    repositories(first: 100, isFork: false) {
      totalCount
      nodes {
        name
      }
    }
  }
}
  ",
  ])
}

fn call_api_for_repos(token: String) -> Result(List(Repo), String) {
  //TODO this pattern is ugly. Fix it
  let org1 = "gleam-lang"
  let org2 = "gleam-experiments"

  io.println("Calling API to get repos in gleam-lang")
  let query1 = construct_repo_query(org1)
  try response_json1 = graphql.call_api(token, query1)
  try repo_list1 = parse_repos(response_json1, org1)

  io.println("Calling API to get repos in gleam-experiments")
  let query2 = construct_repo_query(org2)
  try response_json2 = graphql.call_api(token, query2)
  try repo_list2 = parse_repos(response_json2, org2)

  let repo_list = list.append(repo_list1, repo_list2)

  Ok(repo_list)
}

// Args from command line are actually an Erlang Charlist not strings, so they need to be converted.
pub external type Charlist

external fn charlist_to_string(Charlist) -> String =
  "erlang" "list_to_binary"

fn print_combined_sponsors_and_contributors(args: List(String)) {
  // Parses command line arguments
  try tuple(token, from, to) = parse_args(args)

  // Calls API for Sponsors. Returns List(String) if Ok.
  try sponsors = call_api_for_sponsors(token, option.None, [])
  let str_list_sponsors = list_sponsor_to_list_string(sponsors)

  // NOTE filtering the sponsor list by sponser amount (cents) could also be done here.
  //  let sponsors100 = filter_sponsors(sponsors, 100)
  // TODO: Construct fn to return the avatar_url as well as name and github url in the required MD format
  // Construct fn to generate the filtered sponsors with avatars as a string
  // and append it to the existing output string
  // Returns List(Repo)
  try list_repos = call_api_for_repos(token)
  try acc_list_contributors =
    list_repos
    |> list.try_map(fn(repo: Repo) {
      call_api_for_contributors(
        token,
        from,
        to,
        option.None,
        [],
        repo.org,
        repo.name,
      )
    })
  let flat_contributors = list.flatten(acc_list_contributors)
  let filtered_contributors =
    filter_creator_from_contributors(flat_contributors)
  let str_list_contributors =
    list_contributor_to_list_string(filtered_contributors)
  // Combines all sponsors and all contributors
  let str_sponsors_contributors =
    markdown.unordered_list(case_insensitive_sort(list.append(
      str_list_sponsors,
      str_list_contributors,
    )))
  Ok(str_sponsors_contributors)
}

// Entrypoint fn for Erlang escriptize. Must be called `main`. Takes a
// List(Charlist) formed of whitespace seperated commands to stdin.
// Top level, handles error-handling
pub fn main(args: List(Charlist)) -> Nil {
  start_application_and_deps(GleamContributors)
  io.println("Erlang applications started")

  let args = list.map(args, fn(x) { charlist_to_string(x) })

  let result = case args {
    ["GA", token, filename] -> github_actions(token, filename)
    _other -> print_combined_sponsors_and_contributors(args)
  }

  case result {
    Ok(res) -> {
      io.print(res)
      io.println("Done!")
    }
    Error(e) -> {
      io.println("Got an Error. The message was:")
      io.println(e)
    }
  }
}
